using System.Runtime.Serialization;
using System.Text;
using DG.Tools.XrmMockup;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Metadata;
using XrmEmulator.MetadataSync.Models;

namespace XrmEmulator.MetadataSync.Serialization;

public static class MetadataSerializer
{
    public static void Serialize(
        SyncOptions options,
        Dictionary<string, EntityMetadata> entityMetadata,
        Dictionary<string, Dictionary<int, int>> defaultStateStatus,
        List<MetaPlugin>? plugins,
        OptionSetMetadataBase[]? optionSets,
        Entity? organization,
        Entity? rootBusinessUnit,
        List<Entity>? currencies,
        List<Entity>? workflows,
        List<SecurityRole>? securityRoles)
    {
        var outputDir = Path.GetFullPath(options.OutputDirectory);
        Directory.CreateDirectory(outputDir);

        // Build and serialize the MetadataSkeleton
        var skeleton = new MetadataSkeleton
        {
            EntityMetadata = entityMetadata,
            DefaultStateStatus = defaultStateStatus,
            Plugins = plugins ?? [],
            OptionSets = optionSets ?? [],
            Currencies = currencies ?? [],
            BaseOrganization = organization ?? new Entity("organization"),
            RootBusinessUnit = rootBusinessUnit ?? new Entity("businessunit")
        };

        SerializeToFile(skeleton, Path.Combine(outputDir, "Metadata.xml"));

        // Serialize workflows
        if (workflows is { Count: > 0 })
        {
            var workflowDir = Path.Combine(outputDir, "Workflows");
            Directory.CreateDirectory(workflowDir);

            foreach (var workflow in workflows)
            {
                var name = workflow.GetAttributeValue<string>("name") ?? workflow.Id.ToString();
                var safeName = SanitizeFileName(name);
                SerializeToFile(workflow, Path.Combine(workflowDir, $"{safeName}.xml"));
            }
        }

        // Serialize security roles
        if (securityRoles is { Count: > 0 })
        {
            var rolesDir = Path.Combine(outputDir, "SecurityRoles");
            Directory.CreateDirectory(rolesDir);

            foreach (var role in securityRoles)
            {
                var safeName = SanitizeFileName(role.Name);
                SerializeToFile(role, Path.Combine(rolesDir, $"{safeName}.xml"));
            }

            // Generate TypeDeclarations.cs with security role GUID constants
            GenerateTypeDeclarations(securityRoles, outputDir);
        }
    }

    private static void SerializeToFile<T>(T obj, string filePath)
    {
        var serializer = new DataContractSerializer(typeof(T), GetKnownTypes());
        using var stream = File.Create(filePath);
        serializer.WriteObject(stream, obj);
    }

    private static Type[] GetKnownTypes()
    {
        return
        [
            typeof(Entity),
            typeof(EntityMetadata),
            typeof(AttributeMetadata),
            typeof(OptionSetMetadata),
            typeof(BooleanOptionSetMetadata),
            typeof(OptionSetMetadataBase),
            typeof(MetaPlugin),
            typeof(MetaImage),
            typeof(SecurityRole),
            typeof(RolePrivilege),
            typeof(MetadataSkeleton),
            typeof(EntityReference),
            typeof(Money),
            typeof(OptionSetValue),
            typeof(AliasedValue),
            typeof(EntityCollection)
        ];
    }

    private static void GenerateTypeDeclarations(List<SecurityRole> securityRoles, string outputDir)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// Auto-generated by XrmEmulator.MetadataSync");
        sb.AppendLine("// Contains security role GUID constants");
        sb.AppendLine();
        sb.AppendLine("namespace XrmEmulator.Metadata;");
        sb.AppendLine();
        sb.AppendLine("public static class SecurityRoleGuids");
        sb.AppendLine("{");

        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (var role in securityRoles.OrderBy(r => r.Name))
        {
            var constName = SanitizeIdentifier(role.Name);
            if (!seen.Add(constName)) continue;

            sb.AppendLine($"    public static readonly Guid {constName} = new(\"{role.RoleId}\");");
        }

        sb.AppendLine("}");

        File.WriteAllText(Path.Combine(outputDir, "TypeDeclarations.cs"), sb.ToString());
    }

    private static string SanitizeFileName(string name)
    {
        var invalid = Path.GetInvalidFileNameChars();
        var sanitized = new StringBuilder(name.Length);
        foreach (var c in name)
        {
            sanitized.Append(invalid.Contains(c) ? '_' : c);
        }
        return sanitized.ToString();
    }

    private static string SanitizeIdentifier(string name)
    {
        var sb = new StringBuilder(name.Length);
        foreach (var c in name)
        {
            if (char.IsLetterOrDigit(c))
                sb.Append(c);
            else if (c == ' ' || c == '-' || c == '_')
                sb.Append('_');
        }

        var result = sb.ToString();
        // Ensure it doesn't start with a digit
        if (result.Length > 0 && char.IsDigit(result[0]))
            result = "_" + result;

        return result;
    }
}
